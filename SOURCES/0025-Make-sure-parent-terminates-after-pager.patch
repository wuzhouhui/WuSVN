From fe0f1c9f54315f9b168e3c66cd7cc587e4d04e9c Mon Sep 17 00:00:00 2001
From: wuzhouhui <wuzhouhui250@gmail.com>
Date: Thu, 26 Jan 2017 14:13:28 +0800
Subject: [PATCH 25/95] Make sure parent terminates after pager

If parent terminates before pager, the pager will exits innormally and
make terminal stay in an innormal mode.
---
 subversion/svn/svn.c | 51 +++++++++++++++++++++++++++++++++++++++++----------
 1 file changed, 41 insertions(+), 10 deletions(-)

diff --git a/subversion/svn/svn.c b/subversion/svn/svn.c
index 9b84065..7e4f3d4 100644
--- a/subversion/svn/svn.c
+++ b/subversion/svn/svn.c
@@ -1979,6 +1979,23 @@ const svn_opt_subcommand_desc2_t svn_cl__cmd_table[] =
   { NULL, NULL, {0}, NULL, {0} }
 };
 
+static pid_t pager_pid;
+
+static void pager_exit(svn_boolean_t in_signal)
+{
+  if (!pager_pid)
+    return;
+  if (in_signal)
+    fflush(stdout);
+  close(STDOUT_FILENO);
+  waitpid(pager_pid, NULL, 0);
+  pager_pid = 0;
+}
+
+static void wait_for_pager_atexit(void)
+{
+  pager_exit(FALSE);
+}
 
 /* Version compatibility check */
 static svn_error_t *
@@ -2002,6 +2019,20 @@ check_lib_versions(void)
 /* The cancelation handler setup by the cmdline library. */
 svn_cancel_func_t svn_cl__check_cancel = NULL;
 
+/* A flag to see if we've been cancelled by the client or not. */
+static volatile sig_atomic_t cancelled = FALSE;
+
+/* A signal handler to support cancellation. */
+static void
+signal_handler(int signum)
+{
+  apr_signal(signum, SIG_IGN);
+  cancelled = TRUE;
+  if (signum == SIGTERM || signum == SIGINT || signum == SIGHUP
+      || signum == SIGQUIT || signum == SIGPIPE)
+    pager_exit(TRUE);
+}
+
 /* Add a --search argument to OPT_STATE.
  * These options start a new search pattern group. */
 static void
@@ -2050,8 +2081,7 @@ add_search_pattern_to_latest_group(svn_cl__opt_state_t *opt_state,
  * return SVN_NO_ERROR.
  */
 static svn_error_t *
-sub_main(int *exit_code, int argc, const char *argv[], apr_pool_t *pool,
-		pid_t *pid)
+sub_main(int *exit_code, int argc, const char *argv[], apr_pool_t *pool)
 {
   svn_error_t *err;
   int opt_id;
@@ -3257,6 +3287,12 @@ sub_main(int *exit_code, int argc, const char *argv[], apr_pool_t *pool,
           svn_cl__log) && opt_state.diff.no_color == FALSE)
 			dont_use_color = FALSE;
   }
+
+  if (atexit(wait_for_pager_atexit)) {
+    fprintf(stderr, "atexit failed\n");
+    exit(EXIT_FAILURE);
+  }
+
   if (isatty(STDOUT_FILENO) && (subcommand->cmd_func == svn_cl__blame ||
 		  subcommand->cmd_func == svn_cl__cat ||
 		  subcommand->cmd_func == svn_cl__diff ||
@@ -3270,10 +3306,10 @@ sub_main(int *exit_code, int argc, const char *argv[], apr_pool_t *pool,
       fprintf(stderr, "pipe failed\n");
       exit(EXIT_FAILURE);
     }
-    if ((*pid = fork()) < 0) {
+    if ((pager_pid = fork()) < 0) {
       fprintf(stderr, "fork failed\n");
       exit(EXIT_FAILURE);
-    } else if (*pid == 0) { /* child */
+    } else if (pager_pid == 0) { /* child */
       close(fd[1]);
       if (fd[0] != STDIN_FILENO) {
         if (dup2(fd[0], STDIN_FILENO) != STDIN_FILENO) {
@@ -3375,7 +3411,6 @@ main(int argc, const char *argv[])
 {
   apr_pool_t *pool;
   int exit_code = EXIT_SUCCESS;
-  pid_t pid = 0;
   svn_error_t *err;
 
   /* Initialize the app. */
@@ -3387,7 +3422,7 @@ main(int argc, const char *argv[])
    */
   pool = apr_allocator_owner_get(svn_pool_create_allocator(FALSE));
 
-  err = sub_main(&exit_code, argc, argv, pool, &pid);
+  err = sub_main(&exit_code, argc, argv, pool);
 
   /* Flush stdout and report if it fails. It would be flushed on exit anyway
      but this makes sure that output is not silently lost if it fails. */
@@ -3399,10 +3434,6 @@ main(int argc, const char *argv[])
       svn_cmdline_handle_exit_error(err, NULL, "svn: ");
     }
 
-  if (pid) {
-    close(STDOUT_FILENO);
-    waitpid(pid, NULL, 0);
-  }
   svn_pool_destroy(pool);
 
   svn_cmdline__cancellation_exit();
-- 
1.8.3.1

